class SpikeRunner {
    field Ball ball; // The player ball
    field Array floors; // An array of floor
    field Random random; //A random number generator
    field int floorMax; // Max # of floors on screen
    field int currentFloorAmt; // Number of floors currently contructed - 1 (0 indexed)
    field int refreshRate; // refresh rate of the game
    /** Constructs new Spike Runner game */
    constructor SpikeRunner new() {
        let ball = Ball.new();
        let random = Random.new();
        let floorMax = 4;
        let currentFloorAmt = 0;
        let floors = Array.new(floorMax);
        let refreshRate = 22;
        return this;
    }

    /** Frees up memory when done */
    method void dispose() {
        do ball.dispose();
        do floorsDispose();
        do Memory.deAlloc(this);
        return;
    }

    /** Iterate thru floors array and dispose of each obj individually */
    method void floorsDispose(){
        var int i;
        var Floor floor;
        let i = 0;
        while (i < currentFloorAmt) {
            let floor = floors[i];
            do floor.dispose();
            let i = i + 1;
        }
        return;
    }

    /** Detects ball collision with floor */
    method boolean collisionDetected(Array floors) {
        var int bottomBounds, i;
        var Floor floor;
        let i = 0;
        let bottomBounds = (ball.getY() + ball.getSize());
        while(i < currentFloorAmt) {
            let floor = floors[i];
            //Collision box for ball relative to floor position (Collision box is defined here)
            if(((bottomBounds - 5) < (floor.getY() - 2)) & ((bottomBounds + 5) > (floor.getY() - 2))){
                //If part of floor is not the hole part
                if((ball.getX() < floor.getHoleStart()) | (ball.getX() > floor.getHoleEnd())){
                    return true;
                }
                
            }
            let i = i + 1;
        }
        return false;
    }

    /** Calculates a valid hole position for rendering in-bounds */
    method int generateHoleStartPosition(){
        var int randomNum, holeEnd;
        let randomNum = random.lcg();
        let holeEnd = randomNum + 50;

        if(randomNum < 5) {
            let randomNum = randomNum + 5;
        }
        if(holeEnd > 511){
            let randomNum = randomNum - 55;
        }
        return randomNum;
    }

    /** Performs initial construction of floor object */
    method void constructFloor(int floorNum){
        var Floor floor;
        let floor = Floor.new(generateHoleStartPosition());
        let floors[floorNum] = floor;
        let currentFloorAmt = currentFloorAmt + 1;
        return;
    }

    /** Triggers the animate method for each floor object */
    method void animateFloors(){
        var int i;
        var Floor floor;
        let i = 0;
        while(i < currentFloorAmt){
            let floor = floors[i];
            do floor.animate(); 
            let i = i + 1;
        }
        
        return;
    }

    /** Will dispose of floor that has reached a specific Y value */
    method void respawnAtMaxHeight(){
        var int i;
        var Floor floor;
        let i = 0;
        while(i < currentFloorAmt) {
            let floor = floors[i];
            if(floor.getY() < 30) {
                do floor.respawn(generateHoleStartPosition());
            }
            let i = i + 1;
        }
        return;
    }

    /** Runs the entirety of the game */
    method void run() {
        var char key;
        var boolean quit;
        var int loopCount, floorSpawn, spawnDelay;
        let floorSpawn = 0;
        let spawnDelay = 0;
        let quit = false;
        while(~quit) {
            
            let key = Keyboard.keyPressed();

            //Spawn next floor
            if(spawnDelay = 30) {
               
                do respawnAtMaxHeight();
                
                if(currentFloorAmt = floorMax){
                    let floorSpawn = 0;
                } else {
                    do constructFloor(floorSpawn);
                    let floorSpawn = floorSpawn + 1;
                }
                let spawnDelay = 0;
            }

            //Calculate if ball is touching floor
            if(currentFloorAmt > 0){
                if(collisionDetected(floors)){
                    do ball.setColliding(true);
                } else {
                    do ball.setColliding(false);
                }
            }

            do ball.animate(key);

            if(currentFloorAmt > 0){
                do animateFloors();
            }

            do Sys.wait(refreshRate);
            let spawnDelay = spawnDelay + 1;
            if(key = 81) {
                let quit = true;
                do Screen.clearScreen();
            }
        } 

        return;
    }
}