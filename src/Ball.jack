/** The player entity, a ball */
class Ball {
    field int x, y; // Screen location of center of ball graphic
    field int size; // radius of ball
    field int prevX, prevY; // Screen location of center of ball in previous frame
    field int speed;
    field boolean colliding; //Set to true when touching a floor
    /** Constructs the player (ball) */
    constructor Ball new() {
        let x = 255;
        let y = 10;
        let prevX = x;
        let prevY = y;
        let size = 10;
        let speed = 7;
        let colliding = false;
        do draw();
        return this;
    }

    /** Frees up memory taken by ball */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    method int getX(){
        return x;
    }

    method int getY() {
        return y;
    }

    method int getSize(){
        return size;
    }

    /** Draws the ball to the screen */
    method void draw() {
        do Screen.setColor(true);
        do Screen.drawCircle(x,y,size);
        return;
    }


    /** Erases the ball, readies for next frame of animation */
    method void clear() {
        do Screen.setColor(false);
        do Screen.drawCircle(prevX,prevY,size);
        return;
    }

    /** Returns true if the entirety of the ball can be rendered within the screen's bounds. 
    Prevents graphical OOB errors */
    method boolean inBounds(int nextX, int nextY) {
        if(nextX < (size + 1)){
            return false;
        } 
        if(nextX > (511 - size)) {
            return false;
        }

        if(nextY < size) {
            return false;
        }
        if(nextY > (255 - size)) {
            return false;
        }

        return true;
    }

    /** Detects if the ball is colliding with a floor */
    method void setColliding(boolean collisionState){
        let colliding = collisionState;
        return;
    }

    /** Gravity on the ball, constant speed downwards. */
    method void gravity() {
        var int nextY;
        let nextY = y + 5;
        if(inBounds(x, nextY)) {
            let y = y + 5;
        }
        return;
    }

    /** Right movement on ball, constant speed x+*/
    method void moveRight() {
        var int nextX;
        let nextX = x + speed;
        if(inBounds(nextX, y)){
            let x = x + speed;
        }
        return;
    }

    /** Left movement on ball, constant speed -x*/
    method void moveLeft() {
        var int nextX;
        let nextX = x - speed;
        if(inBounds(nextX, y)){
            let x = x - speed;
        }
        return;
    }

    /** Returns true if if x differs from prevX
    and/or y differs from prevY */
    method boolean ballHasMoved() {
        if((x - prevX) = 0){
            if((y - prevY) = 0){
                return false;
            }
        }
        
        return true;
    }

    /** Runs through all methods that can move the ball, will refresh
    ball drawing if x differs from prevX and/or y differs from prevY */
    method void animate(int key) {
        let prevX = x;
        let prevY = y;
        if(colliding){
            //Move relative to the floor
            let y = y - 2; //SAME SPEED AS FLOOR, make variable instead of constant
        } else {
            do gravity();
        }

        if(key = 130) {
            do moveLeft();
        }

        if(key = 132) {
            do moveRight();
        }

        if(ballHasMoved()){
            do clear();
            do draw();
        }
        return;
    }
}